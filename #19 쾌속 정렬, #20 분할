#19 쾌속 정렬

void quick_sort(int A[], int s, int e) {
    if (s >= e) return;
    int m = partition(A, s, e);
    quick_sort(A, s, m - 1);
    quick_sort(A, m + 1, e);
}

#20 분할

int split(int A[], int s, int e) {
    int pivot = A[s];
    int left = s + 1;
    int right = e;

    // 중복값에서도 무한루프 방지: <, > 비교 사용
    while (left <= right) {
        while (left <= e && A[left] < pivot)  left++;
        while (right >= s && A[right] > pivot) right--;
        if (left < right) {
            swap(&A[left], &A[right]);
            left++; right--;
        } else {
            break;
        }
    }
    swap(&A[s], &A[right]);   // 피벗 제자리
    return right;             // 피벗의 최종 인덱스
}


// 참고
static inline void swap(int *x, int *y) {
    int t = *x; *x = *y; *y = t;
}
